<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OSI Layer 5: Energy Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: #020204;
            color: #e0faff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            touch-action: none;
        }

        /* Abstract UI Style */
        .glass-panel {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }

        .energy-text {
            text-shadow: 0 0 10px currentColor;
        }

        .btn-energy {
            background: linear-gradient(45deg, transparent 5%, rgba(0, 255, 200, 0.1) 5%);
            border: 1px solid rgba(0, 255, 200, 0.3);
            color: #00ffc8;
            padding: 0.8rem 2rem;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .btn-energy::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 200, 0.2), transparent);
            transition: 0.5s;
        }
        
        .btn-energy:hover::before { left: 100%; }
        .btn-energy:hover {
            box-shadow: 0 0 20px rgba(0, 255, 200, 0.4);
            border-color: #00ffc8;
            background: rgba(0, 255, 200, 0.1);
        }

        /* Canvas Container */
        #game-container {
            flex-grow: 1;
            position: relative;
            margin: 0; /* Full screen feel */
            overflow: hidden;
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(2, 2, 4, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .hidden { display: none !important; }

        /* Status Colors */
        .status-active { color: #00ff9d; text-shadow: 0 0 15px #00ff9d; } /* Green */
        .status-wait { color: #ffcc00; text-shadow: 0 0 15px #ffcc00; }   /* Yellow */
        .status-closed { color: #ff0055; text-shadow: 0 0 15px #ff0055; } /* Red */
        .status-offline { color: #888; text-shadow: 0 0 5px #fff; } /* Gray/Offline */

        /* Mobile D-Pad */
        .dpad-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
        }
        .dpad-btn:active { background: rgba(0, 255, 200, 0.2); color: #fff; border-color: #00ffc8; }
        
        /* Difficulty Pop */
        @keyframes diffPop {
            0% { transform: scale(1); color: #fff; }
            50% { transform: scale(1.5); color: #ff0055; }
            100% { transform: scale(1); color: #fff; }
        }
        .animate-diff { animation: diffPop 0.5s ease-in-out; }

        /* Alert Text */
        #alert-text {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px currentColor;
            z-index: 50;
        }
    </style>
</head>
<body>
    
    <!-- Floating HUD -->
    <header class="absolute top-0 left-0 w-full p-4 z-20 flex justify-between items-start pointer-events-none">
        <div class="glass-panel px-4 py-2 pointer-events-auto">
            <h1 class="text-xl font-bold tracking-widest status-active" id="game-title">
                SESSION<span class="text-white opacity-50">FLOW</span>
            </h1>
            <div class="text-[10px] text-gray-400 mt-1 flex gap-3">
                <span>ESTADO: <span id="ui-status-text" class="status-active">ACTIVA</span></span>
                <span>FASE: <span id="ui-level" class="text-white">1</span></span>
            </div>
        </div>

        <div class="glass-panel px-4 py-2 flex gap-6 pointer-events-auto">
            <div class="text-center">
                <div class="text-[9px] text-gray-500 tracking-wider">INTEGRIDAD</div>
                <div id="ui-lives" class="text-lg font-bold status-closed">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            <div class="text-center">
                <div class="text-[9px] text-gray-500 tracking-wider">DATA</div>
                <div id="ui-score" class="text-xl font-bold status-wait">0</div>
            </div>
            <button onclick="togglePause()" id="pause-btn" class="text-xs border border-white/20 px-2 rounded hover:bg-white/10 text-white/70">II</button>
        </div>
    </header>

    <!-- Alert Text Overlay -->
    <div id="alert-text">ALERTA</div>

    <!-- Game Canvas -->
    <div id="game-container">
        <canvas id="gameCanvas" class="block w-full h-full"></canvas>

        <!-- 1. MAIN MENU -->
        <div id="menu-screen" class="overlay">
            <div class="relative z-10 text-center">
                <div class="mb-2 w-32 h-32 mx-auto rounded-full border border-gray-700 flex items-center justify-center relative">
                    <div class="absolute inset-0 rounded-full border-t-2 border-[#00ffc8] animate-spin"></div>
                    <span class="text-4xl">üí†</span>
                </div>
                <h1 class="text-6xl font-bold mb-2 status-active tracking-tight">OSI LAYER 5</h1>
                <p class="text-gray-400 mb-10 tracking-[0.2em] text-sm">ABSTRACT SESSION SIMULATOR</p>
                
                <div class="flex flex-col gap-4">
                    <button onclick="startCampaign()" class="btn-energy">INICIAR VIAJE (CAMPA√ëA)</button>
                    <button onclick="startArcade()" class="btn-energy">MODO INFINITO (ARCADE)</button>
                </div>
            </div>
        </div>

        <!-- 2. LEVEL INTRO -->
        <div id="level-intro-screen" class="overlay hidden">
            <div class="glass-panel p-8 max-w-lg w-full text-center border-t-4 border-[#00ffc8]">
                <h2 id="intro-title" class="text-4xl font-bold text-white mb-2">FASE 1</h2>
                <div class="h-px w-full bg-gradient-to-r from-transparent via-gray-500 to-transparent my-4"></div>
                <p id="intro-desc" class="text-gray-300 mb-6 text-sm leading-relaxed font-light">...</p>
                
                <div class="grid grid-cols-2 gap-4 mb-8">
                    <div class="bg-white/5 p-3 rounded">
                        <div class="text-xs text-gray-500 mb-1">OBJETIVO</div>
                        <div id="intro-task" class="text-sm font-bold text-[#00ffc8]">...</div>
                    </div>
                    <div class="bg-white/5 p-3 rounded">
                        <div class="text-xs text-gray-500 mb-1">AMENAZA</div>
                        <div id="intro-risk" class="text-sm font-bold text-[#ff0055]">...</div>
                    </div>
                </div>
                <button onclick="launchLevel()" class="btn-energy w-full">SINCRONIZAR</button>
            </div>
        </div>

        <!-- 3. LAG RECOVERY -->
        <div id="recovery-ui" class="overlay hidden bg-yellow-900/40">
            <div class="text-center">
                <h3 class="text-3xl font-bold status-wait mb-2 energy-text">‚ö†Ô∏è INESTABILIDAD DE RED</h3>
                <p class="text-white/80 mb-8 text-sm">Re√∫ne los nodos de energ√≠a para estabilizar</p>
                
                <div class="relative w-48 h-48 mx-auto flex items-center justify-center">
                    <svg class="absolute inset-0 w-full h-full -rotate-90">
                        <circle cx="96" cy="96" r="88" stroke="rgba(255,255,255,0.1)" stroke-width="8" fill="none"/>
                        <circle id="timer-circle" cx="96" cy="96" r="88" stroke="#ffcc00" stroke-width="8" fill="none" stroke-dasharray="552" stroke-dashoffset="0" style="transition: stroke-dashoffset 0.1s linear"/>
                    </svg>
                    <div id="timer-text" class="text-4xl font-bold text-white">10.0</div>
                </div>
            </div>
            <div id="fragments-container" class="absolute inset-0 z-20"></div>
        </div>

        <!-- 4. GAME OVER -->
        <div id="gameover-ui" class="overlay hidden">
            <h2 class="text-5xl font-bold status-closed mb-2">SESI√ìN CERRADA</h2>
            <p id="go-reason" class="text-gray-400 mb-8">Conexi√≥n terminada por el host.</p>
            <div class="text-4xl font-light mb-8 text-white"><span id="final-score">0</span> <span class="text-sm text-gray-500">NODOS</span></div>
            <button onclick="goToMenu()" class="btn-energy">REINICIAR SISTEMA</button>
        </div>

        <!-- 5. WIN -->
        <div id="win-ui" class="overlay hidden">
            <h2 class="text-5xl font-bold status-active mb-4">SINCRONIZACI√ìN COMPLETA</h2>
            <p class="text-gray-300 mb-8">Flujo de datos establecido exitosamente.</p>
            <button onclick="nextLevel()" class="btn-energy">SIGUIENTE NODO >></button>
        </div>

        <!-- 6. PAUSE -->
        <div id="pause-ui" class="overlay hidden bg-black/60">
            <h2 class="text-4xl font-bold text-white tracking-widest mb-8">PAUSA</h2>
            <div class="flex flex-col gap-4 w-48">
                <button onclick="togglePause()" class="btn-energy">REANUDAR</button>
                <button onclick="goToMenu()" class="text-gray-400 hover:text-white py-2 text-sm">SALIR AL MEN√ö</button>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls" class="absolute bottom-6 right-6 grid grid-cols-3 gap-3 w-40 h-40 md:hidden z-20">
            <div></div>
            <div class="dpad-btn" id="btn-up">‚ñ≤</div>
            <div></div>
            <div class="dpad-btn" id="btn-left">‚óÄ</div>
            <div class="dpad-btn" id="btn-down">‚ñº</div>
            <div class="dpad-btn" id="btn-right">‚ñ∂</div>
        </div>
    </div>

    <!-- Footer Instructions -->
    <div class="absolute bottom-4 left-4 text-[10px] text-white/30 pointer-events-none hidden md:block">
        USAR [WASD] PARA NAVEGAR EL FLUJO
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        const CONFIG = {
            baseSpeed: 4,
            lagTime: 10.0,
            safeZoneBaseSize: 200,
            safeZoneMoveTime: 8000
        };

        const LEVELS = [
            { id: 1, title: "1. FLUJO DE DATOS", desc: "Establece la conexi√≥n inicial. Transporta los paquetes de energ√≠a al n√∫cleo del servidor.", task: "Transporta 3 Nodos", risk: "Inestabilidad (Lag)", goal: 3, type: 'DELIVERY', hasEnemies: false, serverLocked: false, safeZoneMoving: false },
            { id: 2, title: "2. HANDSHAKE", desc: "El servidor requiere autenticaci√≥n. Encuentra la llave de cifrado para abrir el canal.", task: "Usa Llave, Entrega 3", risk: "Firewall Activo", goal: 3, type: 'DELIVERY_KEY', hasEnemies: false, serverLocked: true, safeZoneMoving: true },
            { id: 3, title: "3. MINER√çA", desc: "El servidor est√° oculto. Recolecta energ√≠a dispersa mientras evitas las anomal√≠as rojas.", task: "Recolecta 5 Nodos", risk: "Anomal√≠as (1-2)", goal: 5, type: 'COLLECTION_ONLY', hasEnemies: true, serverLocked: false, safeZoneMoving: true },
            { id: 4, title: "4. MAESTR√çA", desc: "Mant√©n la sesi√≥n activa bajo condiciones extremas.", task: "Sobrevive y Entrega 5", risk: "Alta Inestabilidad", goal: 5, type: 'FULL_SURVIVAL', hasEnemies: true, serverLocked: true, safeZoneMoving: true }
        ];

        const state = {
            mode: 'MENU',
            levelIdx: 0,
            lives: 3,
            score: 0,
            progress: 0,
            
            difficultyMultiplier: 1.0, // Arcade scaling
            arcadePhase: 0, // 0: Delivery, 1: Auth, 2: Hackers, 3: Chaos

            player: { x: 0, y: 0, radius: 8, color: '#00ffc8', angle: 0, carrying: false, safe: false, trail: [] },
            safeZone: { x: 0, y: 0, r: 0 }, 
            server: { x: 0, y: 0, r: 30, locked: false, active: true, angle: 0, crashed: false },
            
            items: {
                packet: { x: 0, y: 0, active: false, angle: 0 },
                key: { x: 0, y: 0, active: false, angle: 0 }
            },
            
            enemies: [],
            bgNodes: [], 
            
            timers: { lag: null, safeZone: null, crash: null },
            keysCollectedInLag: 0,
            isPaused: false
        };

        const input = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

        // --- SETUP ---
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => { if(e.key==='Escape') togglePause(); input[e.key] = true; });
        window.addEventListener('keyup', e => input[e.key] = false);

        // Mobile Touch
        const touchBtns = { 'btn-up':['w'], 'btn-down':['s'], 'btn-left':['a'], 'btn-right':['d'] };
        Object.keys(touchBtns).forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            const handler = (e, val) => { 
                e.preventDefault(); 
                touchBtns[id].forEach(k => input[k] = val);
                el.style.backgroundColor = val ? 'rgba(0, 255, 200, 0.3)' : '';
            };
            el.addEventListener('touchstart', e => handler(e, true));
            el.addEventListener('touchend', e => handler(e, false));
        });

        function init() {
            resize();
            initBackground();
            requestAnimationFrame(loop);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if(state.mode === 'MENU') {
                state.safeZone = { x: width/2, y: height/2, r: 100 };
            }
        }

        function initBackground() {
            state.bgNodes = [];
            const count = Math.floor((width * height) / 15000); // Density
            for(let i=0; i<count; i++) {
                state.bgNodes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2 + 1
                });
            }
        }

        // --- GAME LOGIC ---
        function startCampaign() {
            state.mode = 'CAMPAIGN';
            state.levelIdx = 0;
            state.score = 0;
            state.lives = 3;
            showLevelIntro();
        }

        function startArcade() {
            state.mode = 'ARCADE';
            state.score = 0;
            state.lives = 3;
            state.levelIdx = -1;
            state.arcadePhase = 0;
            resetGame(true);
            hideOverlays();
            updateHUD(true);
            showAlert("FASE 1: TRANSPORTE SEGURO", "#00ffc8");
        }

        function showLevelIntro() {
            hideOverlays();
            const lvl = LEVELS[state.levelIdx];
            document.getElementById('level-intro-screen').classList.remove('hidden');
            document.getElementById('intro-title').innerText = lvl.title;
            document.getElementById('intro-desc').innerText = lvl.desc;
            document.getElementById('intro-task').innerText = lvl.task;
            document.getElementById('intro-risk').innerText = lvl.risk;
        }

        function launchLevel() {
            hideOverlays();
            const lvl = LEVELS[state.levelIdx];
            resetGame(false, lvl);
            state.progress = 0;
            updateHUD(true);
        }

        function nextLevel() {
            state.levelIdx++;
            if(state.levelIdx >= LEVELS.length) {
                endGame("FLUJO COMPLETO. RED ESTABILIZADA.");
            } else {
                showLevelIntro();
            }
        }

        function resetGame(isArcade, levelConfig = null) {
            state.player.x = width/2;
            state.player.y = height/2;
            state.player.trail = [];
            state.player.carrying = false;
            state.difficultyMultiplier = 1.0;
            state.server.crashed = false;
            if(state.timers.crash) clearTimeout(state.timers.crash);

            state.safeZone = { x: width/2, y: height/2, r: CONFIG.safeZoneBaseSize/2 };

            // ARCADE: Starts Simple (Phase 0)
            // CAMPAIGN: Load config
            const config = isArcade ? 
                { hasEnemies: false, serverLocked: false, safeZoneMoving: false, type: 'DELIVERY' } : 
                levelConfig;

            state.hasEnemies = config.hasEnemies;
            state.serverLocked = config.serverLocked;
            state.safeZoneMoving = config.safeZoneMoving;
            state.levelType = config.type;

            state.server.active = (state.levelType !== 'COLLECTION_ONLY');
            
            if(state.server.active) moveServer();
            spawnPacket();
            
            state.enemies = [];
            if(state.hasEnemies) {
                // Initial enemies for campaign or arcade later phases
                let count = 0;
                if(!isArcade) {
                    if (state.levelIdx === 2) count = 1 + Math.floor(Math.random() * 2);
                    else count = 2 + state.levelIdx;
                }
                for(let i=0; i<count; i++) spawnEnemy();
            }

            if(state.timers.safeZone) clearInterval(state.timers.safeZone);
            if(state.safeZoneMoving) {
                state.timers.safeZone = setInterval(moveSafeZone, CONFIG.safeZoneMoveTime);
            }
        }

        function loop() {
            if(!state.isPaused) update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            if(state.mode === 'MENU' || state.mode === 'LAG' || !document.getElementById('win-ui').classList.contains('hidden')) return;

            // Background
            state.bgNodes.forEach(n => {
                n.x += n.vx; n.y += n.vy;
                if(n.x < 0) n.x = width; if(n.x > width) n.x = 0;
                if(n.y < 0) n.y = height; if(n.y > height) n.y = 0;
            });

            // Player Move
            let dx=0, dy=0;
            if(input.w || input.ArrowUp) dy = -CONFIG.baseSpeed;
            if(input.s || input.ArrowDown) dy = CONFIG.baseSpeed;
            if(input.a || input.ArrowLeft) dx = -CONFIG.baseSpeed;
            if(input.d || input.ArrowRight) dx = CONFIG.baseSpeed;
            if(dx!==0 && dy!==0) { dx*=0.707; dy*=0.707; }

            state.player.x = Math.max(10, Math.min(width-10, state.player.x + dx));
            state.player.y = Math.max(10, Math.min(height-10, state.player.y + dy));

            // Trail
            state.player.trail.push({x: state.player.x, y: state.player.y, alpha: 1.0});
            if(state.player.trail.length > 10) state.player.trail.shift();
            state.player.trail.forEach(t => t.alpha -= 0.1);

            // Safe Check
            const dSafe = Math.hypot(state.player.x - state.safeZone.x, state.player.y - state.safeZone.y);
            state.player.safe = dSafe < state.safeZone.r;
            updateStatusText(); 

            // Collisions
            checkCollisions();
            if(state.hasEnemies) updateEnemies();

            // Random Lag
            if(Math.random() < 0.0003) triggerLag();
            
            // Random Server Crash (Arcade Phase 4+)
            if(state.mode === 'ARCADE' && state.arcadePhase >= 3 && state.server.active && !state.server.crashed) {
                if(Math.random() < 0.002) triggerServerCrash();
            }

            // Rotations
            state.server.angle += 0.02;
            state.items.packet.angle += 0.05;
            state.items.key.angle -= 0.05;
        }

        function triggerServerCrash() {
            state.server.crashed = true;
            showAlert("¬°SERVIDOR CA√çDO!", "#ff0055");
            if(state.timers.crash) clearTimeout(state.timers.crash);
            state.timers.crash = setTimeout(() => {
                state.server.crashed = false;
                showAlert("SERVIDOR REINICIADO", "#00ffc8");
            }, 4000);
        }

        function checkCollisions() {
            // Packet
            if(state.items.packet.active) {
                const canPick = state.levelType === 'COLLECTION_ONLY' || !state.player.carrying;
                if(canPick && Math.hypot(state.player.x - state.items.packet.x, state.player.y - state.items.packet.y) < 25) {
                    if(state.levelType === 'COLLECTION_ONLY') {
                        state.items.packet.active = false;
                        addScore(50);
                        state.progress++;
                        spawnPacket();
                        checkWin();
                    } else {
                        state.player.carrying = true;
                        state.items.packet.active = false;
                    }
                }
            }

            // Key
            if(state.server.active && state.server.locked && state.items.key.active) {
                if(Math.hypot(state.player.x - state.items.key.x, state.player.y - state.items.key.y) < 25) {
                    state.server.locked = false;
                    state.items.key.active = false;
                }
            }

            // Server
            if(state.server.active && state.player.carrying) {
                const d = Math.hypot(state.player.x - state.server.x, state.player.y - state.server.y);
                if(d < state.server.r + 15) {
                    if(state.server.crashed) {
                         // Repel crashed
                        const angle = Math.atan2(state.player.y - state.server.y, state.player.x - state.server.x);
                        state.player.x += Math.cos(angle) * 20;
                        state.player.y += Math.sin(angle) * 20;
                    }
                    else if(state.server.locked) {
                        // Repel locked
                        const angle = Math.atan2(state.player.y - state.server.y, state.player.x - state.server.x);
                        state.player.x += Math.cos(angle) * 20;
                        state.player.y += Math.sin(angle) * 20;
                    } else {
                        deliver();
                    }
                }
            }
        }

        function updateEnemies() {
            state.enemies.forEach(en => {
                let tx = state.player.x, ty = state.player.y;
                
                // --- NEW LOGIC START ---
                // Hackers only chase if player HAS PACKAGE and is NOT SAFE
                const shouldChase = state.player.carrying && !state.player.safe;

                if(!shouldChase) {
                    // Wander logic
                    if(!en.px || Math.random() < 0.02) { 
                        en.px = Math.random()*width; 
                        en.py = Math.random()*height; 
                    }
                    tx = en.px; 
                    ty = en.py;
                }
                // --- NEW LOGIC END ---

                const ang = Math.atan2(ty - en.y, tx - en.x);
                en.x += Math.cos(ang) * en.speed;
                en.y += Math.sin(ang) * en.speed;

                if(!state.player.safe && Math.hypot(state.player.x - en.x, state.player.y - en.y) < 20) {
                    hitPlayer();
                }
            });
        }

        function hitPlayer() {
            state.lives--;
            updateHUD(false);
            
            // Check if player was carrying a packet before resetting state
            if (state.player.carrying) {
                state.player.carrying = false;
                spawnPacket(); // Respawn packet if it was lost
                showAlert("PAQUETE PERDIDO - RESPAWNED", "#ffcc00");
            }

            state.player.x = state.safeZone.x; 
            state.player.y = state.safeZone.y;
            if(state.lives <= 0) endGame("INTEGRIDAD DE SESI√ìN COMPROMETIDA");
        }

        function deliver() {
            state.player.carrying = false;
            addScore(100);
            state.progress++;
            moveServer();
            spawnPacket();
            checkWin();
        }

        function checkWin() {
            if(state.mode === 'CAMPAIGN' && state.progress >= LEVELS[state.levelIdx].goal) {
                document.getElementById('win-ui').classList.remove('hidden');
            }
        }

        // --- ARCADE DIFFICULTY & SCORE ---

        function addScore(amt) { 
            state.score += amt; 
            updateHUD(); 

            if(state.mode === 'ARCADE') {
                checkArcadePhase();
            }
        }

        function checkArcadePhase() {
            // PHASE 1 (0-500): Pure Delivery. Default.
            
            // PHASE 2 (500+): Auth Required
            if(state.score >= 500 && state.arcadePhase < 1) {
                state.arcadePhase = 1;
                state.serverLocked = true;
                state.server.locked = true;
                spawnKey();
                showAlert("FASE 2: PROTOCOLO DE AUTENTICACI√ìN", "#ffcc00");
                state.difficultyMultiplier += 0.1;
            }

            // PHASE 3 (1000+): Hackers Enter
            if(state.score >= 1000 && state.arcadePhase < 2) {
                state.arcadePhase = 2;
                state.hasEnemies = true;
                spawnEnemy(); // Start with 1
                state.safeZoneMoving = true;
                if(state.timers.safeZone) clearInterval(state.timers.safeZone);
                state.timers.safeZone = setInterval(moveSafeZone, CONFIG.safeZoneMoveTime);
                showAlert("FASE 3: INTRUSOS DETECTADOS", "#ff0055");
                state.difficultyMultiplier += 0.1;
            }

            // PHASE 4 (1500+): Server Instability (Crashes) & More Enemies
            if(state.score >= 1500 && state.arcadePhase < 3) {
                state.arcadePhase = 3;
                spawnEnemy(); // Add another
                state.difficultyMultiplier += 0.2;
                showAlert("FASE 4: INESTABILIDAD DE SERVIDOR", "#ff0000");
            }

            // Every 500 after: Just harder
            if(state.score > 1500 && state.score % 500 === 0) {
                increaseArcadeDifficulty();
            }
        }

        function increaseArcadeDifficulty() {
            state.difficultyMultiplier += 0.15;
            if(state.enemies.length < 15) spawnEnemy();
            state.enemies.forEach(en => en.speed += 0.5);
            if(state.safeZone.r > 60) state.safeZone.r -= 10;
            
            const lvlDisp = document.getElementById('ui-level');
            lvlDisp.classList.add('animate-diff');
            setTimeout(() => lvlDisp.classList.remove('animate-diff'), 500);
        }

        function spawnEnemy() {
            state.enemies.push({ 
                x: -20, 
                y: Math.random()*height, 
                speed: (2 + Math.random()) * state.difficultyMultiplier, 
                px:null, 
                py:null 
            });
        }

        function updateHUD(forceActive) {
            document.getElementById('ui-score').innerText = state.score;
            document.getElementById('ui-lives').innerText = "‚ù§Ô∏è".repeat(state.lives);
            
            let levelText = "‚àû";
            if(state.mode === 'CAMPAIGN') levelText = state.levelIdx > -1 ? state.levelIdx+1 : 1;
            else if(state.mode === 'ARCADE') levelText = state.arcadePhase + 1;

            document.getElementById('ui-level').innerText = levelText;
            updateStatusText(forceActive ? "ACTIVA" : null);
        }

        function showAlert(text, color) {
            const el = document.getElementById('alert-text');
            el.innerText = text;
            el.style.color = color;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

        // --- LAG SYSTEM ---
        function triggerLag() {
            if(state.mode !== 'CAMPAIGN' && state.mode !== 'ARCADE') return;
            const prev = state.mode;
            state.mode = 'LAG';
            updateStatusText("LAG");
            document.getElementById('recovery-ui').classList.remove('hidden');
            document.getElementById('fragments-container').innerHTML = '';
            
            state.keysCollectedInLag = 0;
            for(let i=0; i<3; i++) {
                const d = document.createElement('div');
                d.className = 'absolute w-12 h-12 rounded-full border-2 border-yellow-400 bg-yellow-900/50 flex items-center justify-center text-xl cursor-pointer animate-pulse';
                d.innerHTML = '‚ö°';
                d.style.left = (20 + Math.random()*60) + '%';
                d.style.top = (30 + Math.random()*40) + '%';
                const click = (e) => {
                    e.target.remove();
                    state.keysCollectedInLag++;
                    if(state.keysCollectedInLag>=3) resolveLag(prev);
                };
                d.onclick = click; d.ontouchstart = click;
                document.getElementById('fragments-container').appendChild(d);
            }

            let t = CONFIG.lagTime;
            const el = document.getElementById('timer-text');
            const circle = document.getElementById('timer-circle');
            const totalDash = 552; 
            
            if(state.timers.lag) clearInterval(state.timers.lag);
            state.timers.lag = setInterval(() => {
                t -= 0.1;
                el.innerText = t.toFixed(1);
                const offset = totalDash - (t/CONFIG.lagTime) * totalDash;
                circle.style.strokeDashoffset = offset;
                
                if(t <= 0) {
                    clearInterval(state.timers.lag);
                    endGame("TIMEOUT - CONEXI√ìN PERDIDA");
                }
            }, 100);
        }

        function resolveLag(prev) {
            clearInterval(state.timers.lag);
            document.getElementById('recovery-ui').classList.add('hidden');
            state.mode = prev;
        }

        // --- UTILS & HELPERS ---
        function updateStatusText(forceState) {
            const stText = document.getElementById('ui-status-text');
            const mode = forceState || (state.mode === 'LAG' ? 'LAG' : (state.server.crashed ? 'OFFLINE' : (state.player.safe ? 'ACTIVA' : 'VULNERABLE')));
            
            stText.innerText = mode;
            stText.className = ''; 
            
            if(mode === 'ACTIVA') stText.classList.add('status-active');
            else if(mode === 'LAG' || mode === 'VULNERABLE') stText.classList.add('status-wait');
            else if(mode === 'OFFLINE') stText.classList.add('status-offline');
            else stText.classList.add('status-closed');
        }

        function moveSafeZone() {
            state.safeZone.x = Math.random() * (width - 200) + 100;
            state.safeZone.y = Math.random() * (height - 200) + 100;
        }

        function moveServer() {
            do {
                state.server.x = Math.random() * (width - 100) + 50;
                state.server.y = Math.random() * (height - 100) + 50;
            } while(Math.hypot(state.server.x - state.safeZone.x, state.server.y - state.safeZone.y) < state.safeZone.r + 50);
            
            if(state.serverLocked) { state.server.locked = true; spawnKey(); }
        }

        function spawnKey() {
            state.items.key.active = true;
            do {
                state.items.key.x = Math.random() * (width - 100) + 50;
                state.items.key.y = Math.random() * (height - 100) + 50;
            } while(Math.hypot(state.items.key.x - state.safeZone.x, state.items.key.y - state.safeZone.y) < state.safeZone.r);
        }

        function spawnPacket() {
            state.items.packet.active = true;
            state.items.packet.x = Math.random() * (width - 100) + 50;
            state.items.packet.y = Math.random() * (height - 100) + 50;
        }

        function hideOverlays() { document.querySelectorAll('.overlay').forEach(e => e.classList.add('hidden')); }
        function togglePause() { state.isPaused = !state.isPaused; document.getElementById('pause-ui').classList.toggle('hidden'); }
        function goToMenu() { hideOverlays(); document.getElementById('menu-screen').classList.remove('hidden'); state.mode = 'MENU'; }
        
        function endGame(reason) {
            state.mode = 'GAMEOVER';
            if(state.timers.lag) clearInterval(state.timers.lag);
            hideOverlays();
            document.getElementById('gameover-ui').classList.remove('hidden');
            document.getElementById('go-reason').innerText = reason;
            document.getElementById('final-score').innerText = state.score;
        }

        // --- DRAWING ---
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 1. Dynamic Background Network
            ctx.lineWidth = 1;
            for(let i=0; i<state.bgNodes.length; i++) {
                const n = state.bgNodes[i];
                ctx.fillStyle = 'rgba(0, 255, 200, 0.2)';
                ctx.beginPath(); ctx.arc(n.x, n.y, n.size, 0, Math.PI*2); ctx.fill();
                
                // Connections near player
                const d = Math.hypot(state.player.x - n.x, state.player.y - n.y);
                if(d < 150) {
                    ctx.strokeStyle = `rgba(0, 255, 200, ${0.2 * (1 - d/150)})`;
                    ctx.beginPath(); ctx.moveTo(state.player.x, state.player.y); ctx.lineTo(n.x, n.y); ctx.stroke();
                }
            }

            // 2. Safe Zone (Abstract Energy Pool)
            const sz = state.safeZone;
            // Pulsing opacity
            const pulseAlpha = 0.2 + Math.sin(Date.now() / 500) * 0.1;
            
            const grad = ctx.createRadialGradient(sz.x, sz.y, 10, sz.x, sz.y, sz.r);
            grad.addColorStop(0, `rgba(0, 255, 157, ${pulseAlpha})`); // More visible center
            grad.addColorStop(0.7, `rgba(0, 255, 157, ${pulseAlpha * 0.5})`);
            grad.addColorStop(1, 'rgba(0, 255, 157, 0.0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(sz.x, sz.y, sz.r, 0, Math.PI*2); ctx.fill();
            
            // Rotating rings
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00ff9d';
            ctx.setLineDash([15, 15]);
            ctx.beginPath(); ctx.arc(sz.x, sz.y, sz.r, Date.now()/2000, Date.now()/2000 + Math.PI*2); ctx.stroke();
            
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 255, 157, 0.5)';
            ctx.setLineDash([5, 10]);
            ctx.beginPath(); ctx.arc(sz.x, sz.y, sz.r * 0.8, -Date.now()/2000, -Date.now()/2000 + Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);

            // Label
            ctx.fillStyle = 'rgba(0, 255, 157, 0.8)';
            ctx.font = '10px "Rajdhani"';
            ctx.textAlign = 'center';
            ctx.fillText("ZONA SEGURA", sz.x, sz.y + sz.r + 15);

            // 3. Lightning Connection
            if(state.server.active && !state.server.locked && !state.server.crashed) {
                drawLightning(state.player.x, state.player.y, state.server.x, state.server.y, '#00ffc8');
            }

            // 4. Server
            if(state.server.active) {
                ctx.translate(state.server.x, state.server.y);
                if(state.server.crashed) {
                    // Crashed Visuals
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, state.server.r, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = '#555';
                    ctx.font = '20px Arial';
                    ctx.fillText('‚ùå', -10, 8);
                } else {
                    ctx.rotate(state.server.angle);
                    ctx.strokeStyle = state.server.locked ? '#ff0055' : '#0066ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, state.server.r, 0, Math.PI*2); ctx.stroke();
                    
                    ctx.fillStyle = state.server.locked ? 'rgba(255, 0, 85, 0.2)' : 'rgba(0, 102, 255, 0.2)';
                    ctx.beginPath(); 
                    for(let i=0; i<4; i++) {
                        ctx.rect(-15, -15, 30, 30);
                        ctx.rotate(Math.PI/4);
                    }
                    ctx.fill();

                    if(state.server.locked) {
                        ctx.fillStyle = '#ff0055';
                        ctx.font = '20px Arial';
                        ctx.fillText('üîí', -10, 8);
                    }
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
            }

            // 5. Items
            if(state.items.packet.active) drawGlowingOrb(state.items.packet.x, state.items.packet.y, 10, '#ffff00', '‚úâ');
            if(state.server.active && state.server.locked && state.items.key.active) drawGlowingOrb(state.items.key.x, state.items.key.y, 10, '#00ffc8', 'üîë');

            // 6. Enemies
            state.enemies.forEach(en => {
                ctx.fillStyle = '#ff0055';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff0055';
                ctx.beginPath();
                const rx = Math.random()*4 - 2;
                const ry = Math.random()*4 - 2;
                ctx.moveTo(en.x + rx, en.y - 10 + ry);
                ctx.lineTo(en.x + 10 + rx, en.y + 10 + ry);
                ctx.lineTo(en.x - 10 + rx, en.y + 10 + ry);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // 7. Player
            ctx.beginPath();
            state.player.trail.forEach((t, i) => {
                if(i===0) ctx.moveTo(t.x, t.y);
                else ctx.lineTo(t.x, t.y);
            });
            ctx.strokeStyle = state.player.safe ? 'rgba(0, 255, 157, 0.5)' : 'rgba(0, 243, 255, 0.5)';
            ctx.lineWidth = state.player.radius;
            ctx.lineCap = 'round';
            ctx.stroke();

            const pColor = state.player.safe ? '#00ff9d' : '#00f3ff';
            ctx.shadowBlur = 20; ctx.shadowColor = pColor;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(state.player.x, state.player.y, 6, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            
            if(state.player.carrying) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(state.player.x, state.player.y, 12, 0, Math.PI*2); ctx.stroke();
            }
        }

        function drawLightning(x1, y1, x2, y2, color) {
            ctx.strokeStyle = color;
            ctx.shadowBlur = 15; ctx.shadowColor = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            const dist = Math.hypot(x2-x1, y2-y1);
            const steps = dist / 20;
            const dx = (x2-x1)/steps;
            const dy = (y2-y1)/steps;
            let cx = x1, cy = y1;
            for(let i=0; i<steps; i++) {
                cx += dx; cy += dy;
                const offset = (Math.random() - 0.5) * 10;
                ctx.lineTo(cx + offset, cy + offset);
            }
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function drawGlowingOrb(x, y, r, color, char) {
            ctx.shadowBlur = 15; ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, x, y);
            ctx.shadowBlur = 0;
            ctx.strokeStyle = color;
            const pulse = (Math.sin(Date.now()/200) + 1) * 0.5;
            ctx.beginPath(); ctx.arc(x, y, r + pulse*5, 0, Math.PI*2); ctx.stroke();
        }

        init();
    </script>
</body>
</html>